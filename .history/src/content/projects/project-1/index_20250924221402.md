---
title: "Generating persona-based weekly mobility based on LLM"
description: "Part of 2024 30 days Map Challenge"
date: "Mar 18 2024"
demoURL: "https://jasoncpit.github.io/LLM-Mobility-London/"
repoURL: "https://github.com/jasoncpit/LLM-Mobility-London"
---

I’ve been exploring a simple question with unruly consequences: can an LLM plan a week of believable movement for a specific person in a specific city—complete with reasons, places, and routes—without using that person’s real data?

This post shows one example trace (below), explains how it’s generated, what it gets right/wrong, and how this approach differs from recent academic work.

What you’re looking at

The snippet you shared is a Deck.GL TripLayer payload—basically a list of polylines (lon, lat) that render animated paths over time:

```json
{
  "trip_layer": {
    "routes": [
      [[-0.18292, 51.61238]],
      [[-0.18292, 51.61238], [-0.18273, 51.61225], ...],
      ...
    ]
  }
}


Each inner list is a leg of a day (e.g., home → campus, campus → café). The front end “plays” these legs on a map so you can scrub through a day or compare personas over the week.

How the week gets generated (pipeline in plain English)

1) Persona prompt → high-level planner
I define a persona (life stage, home area, commute pattern, interests). A “planner” prompt turns that into a weekly sketch: what happens each day (work, study, sports, food, social).

2) Day planner → activity timeline
A second agent turns the sketch into timestamped activities (leave at 08:10, study 10:00–13:00, badminton at 19:00, etc.) and proposes POI categories (“nearby university library,” “Asian lunch spot”).

3) Tool grounding (Google Places & Directions)
For each activity, I retrieve real POIs and compute feasible routes/times. This keeps the LLM honest: if it says “badminton in Stratford at 7pm,” the path must be drivable/cyclable or on transit with realistic duration.

4) Export → Deck.GL
I serialize the week to TripLayer-friendly JSON and render it with a small React app so you can toggle personas/days and watch the routine unfold.

Privacy note: No personal traces are used. These are synthetic routes chosen by the model from public map data.

Reading the example trace (why it’s interesting)

Even without timestamps in the snippet, a few patterns pop:

Consistent anchors: multiple legs start/end near the same home area (good sign; LLM didn’t “teleport” homes).

Structured commutes: long-ish, plausible north–south and east–west traversals into central and west London. These align with a student/worker persona (lectures or work + evening activities).

Category variety: the week mixes commute legs, study/library zones, food hubs, and sports—exactly the kind of motivation-typed day we want.

Where it’s a bit off:

Odd micro-detours: you’ll see jittery zig-zags that look like over-precise street following. That’s good for realism, but sometimes indicates over-routing (e.g., café detour during a tight work window).

Activity feasibility: without opening-hours checks, the model might send you to a venue outside typical hours, or pick a badminton venue that isn’t actually a badminton venue. Fixable—see next section.

Quick technical details (for fellow builders)

Agent orchestration: 2-level planner (week → day) using structured prompts; state is carried in a minimal memory (persona, previous days’ summaries).

Grounding: Google Places (POI candidates, categories) + Directions/Routes (travel mode, duration). I reject long legs that blow the daily budget and re-ask the model to repair the plan.

Front end: React + Deck.GL TripLayer. Each day is a feature; legs are polylines; UI toggles persona/day and plays the timeline.

If you want to compute basic stats on a trace like this (total daily distance, median leg length), the gist is:

# pseudocode
from math import radians, sin, cos, asin, sqrt
def haversine(p, q):
    lon1, lat1, lon2, lat2 = map(radians, [p[0], p[1], q[0], q[1]])
    dlon, dlat = lon2-lon1, lat2-lat1
    a = sin(dlat/2)**2 + cos(lat1)*cos(lat2)*sin(dlon/2)**2
    return 2*6371000*asin(sqrt(a))  # meters

def total_distance(routes):
    dist = 0
    for leg in routes:
        for i in range(1, len(leg)):
            dist += haversine(leg[i-1], leg[i])
    return dist


Drop in your trip_layer["routes"] and you’ll get a rough daily total.

What’s different from Wang et al. (2024)

Wang et al. treat the agent like a data-aligned urban resident: they extract activity patterns from real user histories, pick routines via LLM self-consistency, and infer daily motivations via retrieval. They also evaluate with divergence metrics and scenario prompts (e.g., pandemic constraints).

My approach is persona-first and tool-grounded:

The LLM decides what to do and why from a persona narrative; Google APIs decide where and how to get there.

It’s built to be interactive and shippable (Deck.GL UI), rather than paper-grade from day one.

I plan to add a tiny “motivation/memory” stub so the week evolves coherently (e.g., “rest day after late gig”), and two lightweight metrics (trip count/dwell histograms; step-length & inter-event-time divergence) to tighten evaluation.

What I learned from this trace

LLMs are great at sequencing: they’re surprisingly good at turning persona intent into a day that feels like a day.

Constraints matter: adding routes and POIs keeps plans plausible; the more constraints (opening hours, budget, weather), the better the week looks.

Failures are instructive: when the model invents an activity that collides with time or distance, a quick repair loop (validate → re-prompt with violations) fixes most issues.

What’s next (practical upgrades)

Opening-hours & feasibility checks: reject venues that are closed; ensure dwell + travel fit the day.

Motivation memory: summarize the last 2–3 days to infer “today’s vibe” (e.g., errands, social, recovery). Feed that into the day planner.

Scenario toggles in the UI: rainy day / Tube strike / visiting parents. One switch, new week.

Two charts on the blog: distance/time distributions vs. a London baseline; POI category mix by persona.